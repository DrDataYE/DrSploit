#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import socket
import threading
from queue import Queue
from rich.console import Console

console = Console()

# Metadata الخاصة بالأداة
metadata = {
    'name': 'TCP Listener',
    'description': 'Tool to listen for TCP connections on a specified port.',
    'authors': ['Your Name'],
    'date': '2023-04-01',
    'license': 'YOUR_LICENSE',
    'references': [
        {'type': 'url', 'ref': 'https://www.example.com/tcp-listener-info'},
    ],
    'options': {
        'LHOST': {'type': 'address', 'description': 'The listen address', 'required': True, 'default': '0.0.0.0'},
        'LPORT': {'type': 'int', 'description': 'The listen port', 'required': True, 'default': 4444}
    }
}
import time

class MetasploitModule:
    def __init__(self):
        self.name = 'Generic Payload Handler'
        self.description = ('This module is a stub that provides all of the '
                            'features of the Metasploit payload system to exploits '
                            'that have been launched outside of the framework.')
        self.license = 'MSF_LICENSE'
        self.author = ['hdm', 'bcook-r7']
        self.references = []
        self.payload = {
            'Space': 10000000,
            'BadChars': '',
            'DisableNops': True
        }
        self.platform = ['android', 'apple_ios', 'bsd', 'java', 'js', 'linux',
                         'osx', 'nodejs', 'php', 'python', 'ruby', 'solaris',
                         'unix', 'win', 'mainframe', 'multi']
        self.arch = 'ARCH_ALL'
        self.targets = [['Wildcard Target', {}]]
        self.default_target = 0
        self.default_options = {'PAYLOAD': 'generic/shell_reverse_tcp'}
        self.advanced_options = {
            'ExitOnSession': [True, "Return from the exploit after a session has been created", True],
            'ListenerTimeout': [False, "The maximum number of seconds to wait for new sessions", 0]
        }
        self.datastore = {}

    def exploit(self):
        if self.datastore.get('DisablePayloadHandler', False):
            print("DisablePayloadHandler is enabled, so there is nothing to do. Exiting!")
            return

        stime = time.time()
        timeout = self.datastore.get('ListenerTimeout', 0)
        while True:
            if self.session_created() and self.datastore.get('ExitOnSession', False):
                break
            if timeout > 0 and (stime + timeout < time.time()):
                break
            time.sleep(1)

    def session_created(self):
        """
        Placeholder for session created check. In an actual implementation,
        this method would contain the logic to determine if a session has
        been created successfully.
        """
        return False


class TCPListener:
    def __init__(self, lhost, lport,args):
        self.lhost = lhost
        self.lport = lport
        self.sessions = {}
        self.session_id = 0
        self.args = args
        self.command_queue = Queue()

    def handle_client(self, client_socket, session_id):
        with client_socket as sock:
            self.sessions[session_id] = sock
            while True:
                if not self.command_queue.empty():
                    command = self.command_queue.get()
                    if command == 'exit':
                        break
                try:
                    data = sock.recv(1024)
                    if not data:
                        break
                    console.print(f"Session {session_id}: Received: {data.decode('utf-8')}")
                    sock.send(b"ACK")
                except ConnectionResetError:
                    console.print(f"[bold red]Session {session_id}: Connection reset by peer")
                    break
        del self.sessions[session_id]

    def start(self):
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server:
            server.bind((self.lhost, self.lport))
            server.listen(5)
            console.print(f"[*] Listening on {self.lhost}:{self.lport}")

            while True:
                client, addr = server.accept()
                session_id = self.session_id
                self.session_id += 1
                console.print(f"[*] Accepted connection from {addr[0]}:{addr[1]} (Session ID: {session_id})")
                client_handler = threading.Thread(target=self.handle_client, args=(client, session_id))
                client_handler.start()
                if self.args['start']:
                    while True:
                        command = input("shell> ")
                        if command == 'exit':
                            break
                        if ' ' in command:
                            session_id, cmd = command.split(' ', 1)
                            self.send_command(int(session_id), cmd)
                        else:
                            self.send_command(int(session_id), command)
                            self.recv_command(int(session_id), command)

    def send_command(self, session_id, command):
        if session_id in self.sessions:
            try:
                self.sessions[session_id].send(command.encode())
            except Exception as e:
                console.print(f"[bold red]Error sending command to session {session_id}: {e}")
        else:
            console.print(f"[bold red]Session {session_id} not found")
    def recv_command(self, session_id, command):
        if session_id in self.sessions:
            try:
                
                print(self.sessions[session_id].recv(1024))
            except Exception as e:
                console.print(f"[bold red]Error sending command to session {session_id}: {e}")
        else:
            console.print(f"[bold red]Session {session_id} not found")

def run(args):
    lhost = args.get('LHOST', '0.0.0.0')
    lport = args.get('LPORT', 4446)
    listener = TCPListener(lhost, lport,args)
    listener.start()
    